import pyaudio
import wave
import numpy as np
from skey import detect_key
import tempfile
import os
from collections import Counter, deque
import sys
import logging
import math
import serial

# --- Configuration ---
arduino = serial.Serial('COM3', 9600)

# --- Suppress logs from skey ---
logging.getLogger().setLevel(logging.ERROR)

# --- Audio settings ---
CHUNK = 1024
FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 44100

# --- Accuracy settings ---
BUFFER_SECONDS = 15
OVERLAP_SECONDS = 10
MAX_HISTORY = 3
DEVICE = "cpu"

# --- Volume visualization settings ---
SMOOTH_WINDOW = 15
DYNAMIC_SCALE = True
MANUAL_SCALE = 2000
MIN_VALID_SAMPLES = 100

# --- Volume normalization for Arduino ---
MAX_RMS_THRESHOLD = 3500

# --- Initialize ---
p = pyaudio.PyAudio()
print("\nAvailable audio input devices:")
for i in range(p.get_device_count()):
    dev = p.get_device_info_by_index(i)
    if dev["maxInputChannels"] > 0:
        print(f"  [{i}] {dev['name']}")

try:
    device_index = int(input("\nEnter the device index to use: "))
except ValueError:
    device_index = None

recent_predictions = []
overlap_frames = []
volume_history = deque(maxlen=SMOOTH_WINDOW)

stream = p.open(format=FORMAT,
                channels=CHANNELS,
                rate=RATE,
                input=True,
                input_device_index=device_index,
                frames_per_buffer=CHUNK)

print(f"\nðŸŽ§ Starting live key detection...")
print(f"- Buffer: {BUFFER_SECONDS}s")
print(f"- Overlap: {OVERLAP_SECONDS}s")
print(f"- Smoothing: last {MAX_HISTORY} predictions")
print(f"- Device: {DEVICE}")
print("Press Ctrl+C to stop.\n")

try:
    while True:
        frames = []

        if overlap_frames:
            frames.extend(overlap_frames)

        new_frames_needed = (
            int(RATE / CHUNK * (BUFFER_SECONDS - OVERLAP_SECONDS))
            if overlap_frames else int(RATE / CHUNK * BUFFER_SECONDS)
        )

        print("\nRecording... (live volume updates below)")
        for _ in range(new_frames_needed):
            # Read audio frame
            try:
                data = stream.read(CHUNK, exception_on_overflow=False)
            except IOError:
                continue

            frames.append(data)

            # --- Calculate RMS ---
            audio_data = np.frombuffer(data, dtype=np.int16)
            if len(audio_data) < MIN_VALID_SAMPLES:
                rms = 0.0
            else:
                rms = math.sqrt(np.mean(audio_data.astype(np.float64) ** 2))

            if math.isnan(rms) or rms < 0:
                rms = 0.0

            # --- Smooth volume ---
            volume_history.append(rms)
            avg_rms = np.mean(volume_history)
            if math.isnan(avg_rms):
                avg_rms = 0.0

            # --- Console scaling ---
            if DYNAMIC_SCALE:
                scale = max(MANUAL_SCALE, np.max(volume_history) * 1.5)
            else:
                scale = MANUAL_SCALE

            normalized_console = min(1.0, avg_rms / scale)
            bar_len = int(normalized_console * 50)
            bar = "â–ˆ" * bar_len
            sys.stdout.write(f"\rVolume: {bar:<50} {avg_rms:8.1f}")
            sys.stdout.flush()

            # ---------------------------------------------------
            #         TRUE LIVE VOLUME SEND TO ARDUINO
            # ---------------------------------------------------
            try:
                normalized_volume = avg_rms / MAX_RMS_THRESHOLD * 10
                volume_level = min(10, max(1, round(normalized_volume)))
                arduino.write(f"{volume_level}-\n".encode())  # '-' means "no key yet"
            except:
                pass
            # ---------------------------------------------------

        print("\nRecording complete. Analyzing key...\n")

        # Save overlap frames
        overlap_frame_count = int(RATE / CHUNK * OVERLAP_SECONDS)
        overlap_frames = frames[-overlap_frame_count:]

        # Save temp WAV file for key detection
        with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
            temp_path = temp_file.name
            wf = wave.open(temp_path, 'wb')
            wf.setnchannels(CHANNELS)
            wf.setsampwidth(p.get_sample_size(FORMAT))
            wf.setframerate(RATE)
            wf.writeframes(b''.join(frames))
            wf.close()

        try:
            # --- Key detection ---
            result = detect_key(temp_path, extension="wav", device=DEVICE)

            if isinstance(result, list):
                key_detected = result[0] if result else "Unknown"
            elif isinstance(result, dict):
                key_detected = result.get('key', 'Unknown')
            else:
                key_detected = str(result)

            recent_predictions.append(key_detected)
            if len(recent_predictions) > MAX_HISTORY:
                recent_predictions.pop(0)

            key_counts = Counter(recent_predictions)
            smoothed_key = key_counts.most_common(1)[0][0]
            confidence = key_counts.most_common(1)[0][1]

            print(f"ðŸŽ¶ Raw detection: {key_detected}")
            print(f"ðŸŽµ Smoothed key: {smoothed_key} (confidence: {confidence}/{len(recent_predictions)})")

            # --- Final volume ---
            final_rms = np.mean(volume_history) if volume_history else 0
            normalized_volume = final_rms / MAX_RMS_THRESHOLD * 10
            volume_level = min(10, max(1, round(normalized_volume)))

            print(f"ðŸ”Š Volume Level: {volume_level}/10 (Raw RMS: {final_rms:.1f})")

            # --- Send combined data after analysis ---
            try:
                key_part = smoothed_key if smoothed_key not in ["Unknown", "None"] else "-"
                data_to_send = f"{volume_level}{key_part}\n"
                arduino.write(data_to_send.encode())
                print(f"-> Sent to Arduino: {data_to_send.strip()}")
            except Exception as e:
                print(f"Arduino connection or send error: {e}")

            print(f"Recent history: {recent_predictions}")
            print("-" * 50)

        except Exception as e:
            print(f"Error during detection: {e}")

        finally:
            os.unlink(temp_path)

except KeyboardInterrupt:
    print("\n\nStopping live key detection...")
    stream.stop_stream()
    stream.close()
    p.terminate()
    print("âœ… Done.")
